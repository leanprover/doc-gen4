import MD4Lean
import DocGen4.Output.Template
import UnicodeBasic

open Lean DocGen4.Process

namespace DocGen4
namespace Output

/-- Auxiliary function for `splitAround`. -/
@[specialize] partial def splitAroundAux (s : String) (p : Char → Bool) (b i : String.Pos.Raw) (r : List String) : List String :=
  if String.Pos.Raw.atEnd s i then
    let r := (String.Pos.Raw.extract s b i)::r
    r.reverse
  else
    let c := String.Pos.Raw.get s i
    if p c then
      let i := String.Pos.Raw.next s i
      splitAroundAux s p i i (c.toString :: String.Pos.Raw.extract s b (i.decreaseBy 1) :: r)
    else
      splitAroundAux s p b (String.Pos.Raw.next s i) r

/--
  Similar to `String.split` in Lean core, but keeps the separater.
  e.g. `splitAround "a,b,c" (fun c => c = ',') = ["a", ",", "b", ",", "c"]`
-/
def splitAround (s : String) (p : Char → Bool) : List String := splitAroundAux s p 0 0 []

private def isAutoGeneratedSuffix (s : String) : Bool :=
  s == "rec" || s == "recOn" || s == "casesOn" || s == "noConfusion" ||
  s == "noConfusionType" || s == "below" || s == "brecOn"

/--
  This function try to find the given name, both globally and in current module.

  For global search, a precise name is need. If the global search fails, the function
  tries to find a local one that ends with the given search name.
-/
def nameToLink? (s : String) : HtmlM (Option String) := do
  let res ← getResult
  if s.endsWith ".lean" && s.contains '/' then
    return (← getRoot) ++ s.dropEnd 5 ++ ".html"
  else if let some name := Lean.Syntax.decodeNameLit ("`" ++ s) then
    -- with exactly the same name
    if res.name2ModIdx.contains name && !isPrivateName name then
      -- Auto-generated eliminators: link to parent type instead
      if let .str parent suffix := name then
        if isAutoGeneratedSuffix suffix &&
            res.name2ModIdx.contains parent && !isPrivateName parent then
          return ← declNameToLink parent
      declNameToLink name
    -- module name
    else if res.moduleNames.contains name then
      moduleNameToLink name
    -- find similar name in the same module
    else
      match (← getCurrentName) with
      | some currentName =>
        let info? :=
          res.moduleInfo[currentName]! |>.members |>.iter
            |> filterDocInfo
            |>.filter (!isPrivateName ·.getName)
            |>.find? (sameEnd ·.getName name)
        if let some info := info? then
          declNameToLink info.getName
        else return none
      | _ => return none
  else
    return none
  where
    -- check if two names have the same ending components
    sameEnd n1 n2 :=
      List.zip n1.componentsRev n2.componentsRev
      |>.all fun ⟨a, b⟩ => a == b

/--
  Extend links with following rules:

  1. if the link starts with `##`, a name search is used, and will use `find` if not found
  2. if the link starts with `#`, it's treated as id link, no modification
  3. if the link starts with `http`, it's an absolute one, no modification
  4. otherwise it's a relative link, extend it with base url
-/
def extendLink (s : String)  : HtmlM String := do
  -- for intra doc links
  if s.startsWith "##" then
    if let some link ← nameToLink? (s.drop 2).copy then
      return link
    else
      return s!"{← getRoot}find/?pattern={s.drop 2}#doc"
  -- for id
  else if s.startsWith "#" then
    return s
  -- for absolute and relative urls
  else if s.startsWith "http" then
    return s
  else return ((← getRoot) ++ s)

/-- Find a bibitem if `href` starts with `thePrefix`. -/
def findBibitem? (href : String) (thePrefix : String := "") : HtmlM (Option BibItem) := do
  if href.startsWith thePrefix then
    pure <| (← read).refsMap[href.drop thePrefix.length |>.copy]?
  else
    pure .none

/-- Flattens an array of `MD4Lean.AttrText` to a plain `String`. -/
def attrTextToString (ts : Array MD4Lean.AttrText) : String :=
  String.join <|
  ts.toList.map fun
    | .normal s => s
    | .entity s => s
    -- CommonMark requires that null characters be replaced by the Unicode replacement character.
    | .nullchar => "\uFFFD"

mutual
/-- Extracts plain text from a single `MD4Lean.Text`, ignoring all formatting. -/
def textToPlaintext (t : MD4Lean.Text) : String :=
  match t with
  | .normal s => s
  | .nullchar => "\uFFFD"
  | .br _ => "\n"
  | .softbr _ => "\n"
  | .entity s => s
  | .em ts => textsToPlaintext ts
  | .strong ts => textsToPlaintext ts
  | .u ts => textsToPlaintext ts
  | .del ts => textsToPlaintext ts
  | .a _ _ _ ts => textsToPlaintext ts
  | .img _ _ alt => textsToPlaintext alt
  | .code ss => String.join ss.toList
  | .latexMath ss => String.join ss.toList
  | .latexMathDisplay ss => String.join ss.toList
  | .wikiLink _ ts => textsToPlaintext ts
termination_by sizeOf t

/-- Extract plain text from an array of `MD4Lean.Text`. -/
def textsToPlaintext (ts : Array MD4Lean.Text) : String :=
  ts.foldl (init := "") fun str t => str ++ textToPlaintext t
termination_by sizeOf ts
end

/--
  Generates an `id` attribute for heading elements, with the following rules:

  1. Characters in `letter`, `mark`, `number` and `symbol` Unicode categories are preserved.
  2. Any sequences of characters in `punctuation`, `separator` and `other` categories are replaced by a single dash.
  3. Cases (upper and lower) are preserved.
-/
def mdGetHeadingId (texts : Array MD4Lean.Text) : String :=
  textsToPlaintext texts |> replaceCharSeq unicodeToDrop "-"
  where
    textsToPlaintext ts := String.join (ts.toList.map textToPlaintext)
    replaceCharSeq pattern replacement s :=
      s.splitToList pattern
      |>.filter (!·.isEmpty)
      |> replacement.intercalate
    unicodeToDrop (c : Char) : Bool :=
      -- punctuation (`P`), separator (`Z`), other (`C`)
      c ∈ Unicode.GC.P ||| Unicode.GC.Z ||| Unicode.GC.C

/-- Checks whether a fenced code block language allows auto-linking. -/
def isLeanCode (lang : Array MD4Lean.AttrText) : Bool :=
  let s := attrTextToString lang
  s.isEmpty || s == "lean"

/--
Automatically adds intra-documentation links for code content.
-/
def autoLinkInline (ss : Array String) : HtmlM (Array Html) := do
  let mut result : Array Html := #[]
  for s in ss do
    let parts := splitAround s unicodeToSplit
    for part in parts do
      match ← nameToLink? part with
      | some link =>
        result := result.push <| Html.element "a" true #[("href", link)] #[Html.text part]
      | none =>
        let sHead := part.dropEndWhile (· != '.') |>.copy
        let sTail := part.takeEndWhile (· != '.') |>.copy
        match ← nameToLink? sTail with
        | some link =>
          if !sHead.isEmpty then
            result := result.push <| Html.text sHead
          result := result.push <| Html.element "a" true #[("href", link)] #[Html.text sTail]
        | none =>
          result := result.push <| Html.text part
  return result
  where
    unicodeToSplit (c : Char) : Bool :=
      -- separator (`Z`), other (`C`)
      c ∈ Unicode.GC.Z ||| Unicode.GC.C

mutual

/--
Renders a single `MD4Lean.Text` inline element to HTML, while processing custom extensions such as
bibliography items. `inLink` suppresses auto-linking inside `<a>` to avoid nested anchors.
-/
partial def renderText (t : MD4Lean.Text) (funName : String) (inLink : Bool := false) : HtmlM (Array Html) := do
  match t with
  | .normal s => return #[Html.text s]
  | .nullchar => return #[Html.raw "\uFFFD"]
  | .br _ => return #[Html.raw "<br>\n"] -- This avoids <br></br>, which is incorrect HTML5
  | .softbr _ => return #[Html.raw "\n"]
  | .entity s => return #[Html.raw s]
  | .em ts =>
    let inner ← renderTexts ts funName inLink
    return #[Html.element "em" true #[] inner]
  | .strong ts =>
    let inner ← renderTexts ts funName inLink
    return #[Html.element "strong" true #[] inner]
  | .u ts =>
    let inner ← renderTexts ts funName inLink
    return #[Html.element "u" true #[] inner]
  | .del ts =>
    let inner ← renderTexts ts funName inLink
    return #[Html.element "del" true #[] inner]
  | .a href title _isAuto children =>
    let hrefStr := attrTextToString href
    let titleStr := attrTextToString title
    let bibitem ← findBibitem? hrefStr "references.html#ref_"
    let extHref ← extendLink hrefStr
    match bibitem with
    | .some bibitem =>
      let newBackref ← addBackref bibitem.citekey funName
      let childrenHtml ← renderTexts children funName (inLink := true)
      let changeName : Bool :=
        if let #[.normal s] := children then
          s == bibitem.citekey
        else
          false
      let newChildren : Array Html :=
        if changeName then #[Html.text bibitem.tag] else childrenHtml
      let mut attrs : Array (String × String) := #[("href", extHref)]
      attrs := attrs.push ("title", bibitem.plaintext)
      attrs := attrs.push ("id", s!"_backref_{newBackref.index}")
      return #[Html.element "a" true attrs newChildren]
    | .none =>
      let childrenHtml ← renderTexts children funName (inLink := true)
      let mut attrs : Array (String × String) := #[("href", extHref)]
      if !titleStr.isEmpty then
        attrs := attrs.push ("title", titleStr)
      return #[Html.element "a" true attrs childrenHtml]
  | .img src title alt =>
    let srcStr := Html.escape (attrTextToString src)
    let titleStr := Html.escape (attrTextToString title)
    let altTexts := alt.toList.map textToPlaintext
    let altStr := Html.escape (String.join altTexts)
    let mut s := s!"<img src=\"{srcStr}\" alt=\"{altStr}\""
    if !titleStr.isEmpty then
      s := s ++ s!" title=\"{titleStr}\""
    s := s ++ ">"
    return #[Html.raw s]
  | .code ss =>
    let inner ← if inLink then
        pure #[Html.text (String.join ss.toList)]
      else
        autoLinkInline ss
    return #[Html.element "code" true #[] inner]
  -- Math is rendered with dollar signs because MathJax will later render them
  | .latexMath ss =>
    let content := String.join ss.toList
    return #[Html.raw s!"${Html.escape content}$"]
  -- Math is rendered with dollar signs because MathJax will later render them
  | .latexMathDisplay ss =>
    let content := String.join ss.toList
    return #[Html.raw s!"$${Html.escape content}$$"]
  | .wikiLink target children =>
    let inner ← renderTexts children funName inLink
    let targetStr := attrTextToString target
    return #[Html.element "x-wikilink" true #[("data-target", targetStr)] inner]

/-- Render an array of `MD4Lean.Text` inline elements to HTML. -/
partial def renderTexts (texts : Array MD4Lean.Text) (funName : String) (inLink : Bool := false) : HtmlM (Array Html) := do
  let mut result : Array Html := #[]
  for t in texts do
    result := result ++ (← renderText t funName inLink)
  return result

/-- Render a single `MD4Lean.Block` element to HTML. -/
partial def renderBlock (block : MD4Lean.Block) (funName : String) (tight : Bool := false) : HtmlM (Array Html) := do
  match block with
  | .p texts =>
    let inner ← renderTexts texts funName
    if tight then
      return inner
    else
      return #[Html.element "p" true #[] inner]
  | .ul isTight _mark items =>
    let mut lis : Array Html := #[]
    for item in items do
      let liHtml ← renderLi item funName isTight
      lis := lis ++ liHtml
    return #[Html.element "ul" true #[] lis]
  | .ol isTight start _mark items =>
    let mut lis : Array Html := #[]
    for item in items do
      let liHtml ← renderLi item funName isTight
      lis := lis ++ liHtml
    let attrs : Array (String × String) :=
      if start != 1 then #[("start", toString start)] else #[]
    return #[Html.element "ol" true attrs lis]
  | .hr => return #[Html.raw "<hr>\n"]
  | .header level texts =>
    let id := mdGetHeadingId texts
    let inner ← renderTexts texts funName
    let anchor := Html.element "a" true #[("class", "hover-link"), ("href", s!"#{id}")] #[Html.text "#"]
    let children := inner.push (Html.text " ") |>.push anchor
    let tag := s!"h{level}"
    return #[Html.element tag true #[("id", id), ("class", "markdown-heading")] children]
  | .code _info lang _fenceChar content =>
    let langStr := attrTextToString lang
    let codeAttrs : Array (String × String) :=
      if !langStr.isEmpty then #[("class", s!"language-{langStr}")] else #[]
    let inner : Array Html ←
      if isLeanCode lang then
        autoLinkInline content
      else
        pure #[Html.text (String.join content.toList)]
    let codeElem := Html.element "code" true codeAttrs inner
    return #[Html.element "pre" true #[] #[codeElem]]
  | .html content =>
    return #[Html.raw (String.join content.toList)]
  | .blockquote blocks =>
    let mut inner : Array Html := #[]
    for b in blocks do
      inner := inner ++ (← renderBlock b funName)
    return #[Html.element "blockquote" true #[] inner]
  | .table head body =>
    let mut headCells : Array Html := #[]
    for cell in head do
      let cellHtml ← renderTexts cell funName
      headCells := headCells.push (Html.element "th" true #[] cellHtml)
    let headRow := Html.element "tr" true #[] headCells
    let thead := Html.element "thead" true #[] #[headRow]
    let mut bodyRows : Array Html := #[]
    for row in body do
      let mut rowCells : Array Html := #[]
      for cell in row do
        let cellHtml ← renderTexts cell funName
        rowCells := rowCells.push (Html.element "td" true #[] cellHtml)
      bodyRows := bodyRows.push (Html.element "tr" true #[] rowCells)
    let tbody := Html.element "tbody" true #[] bodyRows
    return #[Html.element "table" true #[] #[thead, tbody]]

/-- Render a list item to HTML. -/
partial def renderLi (li : MD4Lean.Li MD4Lean.Block) (funName : String) (tight : Bool) : HtmlM (Array Html) := do
  let mut inner : Array Html := #[]
  if li.isTask then
    let checked := li.taskChar == some 'x' || li.taskChar == some 'X'
    if checked then
      inner := inner.push (Html.raw "<input type=\"checkbox\" checked=\"\" disabled=\"\">")
    else
      inner := inner.push (Html.raw "<input type=\"checkbox\" disabled=\"\">")
  for b in li.contents do
    inner := inner ++ (← renderBlock b funName tight)
  return #[Html.element "li" true #[] inner]

end

/-- Find all references in a markdown text. -/
partial def findAllReferences (refsMap : Std.HashMap String BibItem) (s : String) (i : s.Pos := s.startPos)
    (ret : Std.HashSet String := ∅) : Std.HashSet String :=
  let lps := i.find '['
  if hs : lps ≠ s.endPos then
    let lpe := lps.find ']'
    if lpe ≠ s.endPos then
      let citekey := s.extract (lps.next hs) lpe
      match refsMap[citekey]? with
      | .some _ => findAllReferences refsMap s lpe (ret.insert citekey)
      | .none => findAllReferences refsMap s lpe ret
    else
      ret
  else
    ret

/-- Convert docstring to Html. -/
def docStringToHtml (docString : String ⊕ VersoDocString) (funName : String) : HtmlM (Array Html) := do
  let docString :=
    match docString with
    | .inl md => md
    -- TODO: natively render Verso docstrings
    | .inr v => versoDocToMarkdown v
  let refsMarkdown := "\n\n" ++ (String.join <|
    (findAllReferences (← read).refsMap docString).toList.map fun s =>
      s!"[{s}]: references.html#ref_{s}\n")
  let flags := MD4Lean.MD_DIALECT_GITHUB ||| MD4Lean.MD_FLAG_LATEXMATHSPANS ||| MD4Lean.MD_FLAG_NOHTML
  match MD4Lean.parse (docString ++ refsMarkdown) flags with
  | .some doc =>
    let mut result : Array Html := #[]
    for block in doc.blocks do
      result := result ++ (← renderBlock block funName)
    return result
  | .none =>
    addError <| "Error: failed to parse markdown:\n" ++ docString
    return #[.raw "<span style='color:red;'>Error: failed to parse markdown: </span>", .text docString]
end Output
end DocGen4
