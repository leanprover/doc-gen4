/-
Copyright (c) 2021 Henrik Böving. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Henrik Böving
-/
import DocGen4.Process
import DocGen4.Output.ToHtmlFormat
import DocGen4.RenderedCode

namespace DocGen4.Output

open scoped DocGen4.Jsx
open Lean System Widget Elab Process

def basePathComponent := "doc"
def basePath (buildDir : System.FilePath) := buildDir / basePathComponent
def srcBasePath (buildDir : System.FilePath) := basePath buildDir / "src"
def declarationsBasePath (buildDir : System.FilePath) := buildDir / "doc-data"

/-- The structure representing a processed bibitem. -/
structure BibItem where
  /-- The cite key as in the bib file. -/
  citekey : String
  /-- The tag generated by bib processor, e.g. `[Doe12]`.
  Should be plain text and should not be escaped. -/
  tag : String
  /-- The HTML generated by bib processor, e.g.
  `John Doe. <i>Test</i>. 2012.`-/
  html : String
  /-- The plain text form of `html` field. Should not be escaped. -/
  plaintext : String
  deriving FromJson, ToJson

/-- The structure representing a backref item. -/
structure BackrefItem where
  /-- The cite key as in the bib file. -/
  citekey : String
  /-- The name of the module. -/
  modName : Name
  /-- The name of the function, as a string. It is empty if the backref is in modstring. -/
  funName : String
  /-- The index of the backref in that module, starting from zero. -/
  index : Nat
  deriving FromJson, ToJson, Inhabited

/--
The context used in the `BaseHtmlM` monad for HTML templating.
-/
structure SiteBaseContext where

  /--
  The build directory (provided by lake).
  -/
  buildDir : System.FilePath

  /--
  The module hierarchy as a tree structure.
  -/
  hierarchy : Hierarchy
  /--
  How far away we are from the page root, used for relative links to the root.
  -/
  depthToRoot: Nat
  /--
  The name of the current module if there is one, there exist a few
  pages that don't have a module name.
  -/
  currentName : Option Name
  /--
  The list of references, as an array.
  -/
  refs : Array BibItem

/--
Declaration decorator function type: given a module name, declaration name, and declaration kind,
returns optional extra HTML to inject into the declaration's rendering.
This enables external tools to add badges, links, or other decorations to declarations.
-/
abbrev DeclarationDecoratorFn := Name → Name → String → Array Html

/--
The default declaration decorator that produces no extra HTML.
-/
def defaultDeclarationDecorator : DeclarationDecoratorFn := fun _ _ _ => #[]

/--
The read-only context used in the `HtmlM` monad for HTML templating.
-/
structure SiteContext where
  /--
  The full analysis result from the Process module.
  -/
  result : AnalyzerResult
  /--
  A function to link declaration names to their source URLs, usually Github ones.
  -/
  sourceLinker : Name → Option DeclarationRange → String
  /--
  The references as a map.
  -/
  refsMap : Std.HashMap String BibItem
  /--
  A function to decorate declarations with extra HTML (e.g., verification badges).
  Receives (moduleName, declarationName, declarationKind) and returns extra HTML.
  Defaults to producing no extra HTML.
  -/
  declarationDecorator : DeclarationDecoratorFn := defaultDeclarationDecorator

/--
The writable state used in the `HtmlM` monad for HTML templating.
-/
structure SiteState where
  /--
  The list of back references, as an array.
  -/
  backrefs : Array BackrefItem := #[]
  /--
  The errors occurred during the process.
  -/
  errors : String := ""

def setCurrentName (name : Name) (ctx : SiteBaseContext) := {ctx with currentName := some name}

abbrev BaseHtmlT := ReaderT SiteBaseContext
abbrev BaseHtmlM := BaseHtmlT Id

abbrev HtmlT (m) := StateT SiteState <| ReaderT SiteContext <| BaseHtmlT m
abbrev HtmlM := HtmlT Id

def HtmlT.run (x : HtmlT m α) (state : SiteState) (ctx : SiteContext)
    (baseCtx : SiteBaseContext) : m (α × SiteState) :=
  StateT.run x state |>.run ctx |>.run baseCtx

def HtmlM.run (x : HtmlM α) (state : SiteState) (ctx : SiteContext)
    (baseCtx : SiteBaseContext) : α × SiteState :=
  StateT.run x state |>.run ctx |>.run baseCtx |>.run

instance [Monad m] : MonadLift HtmlM (HtmlT m) where
  monadLift x := do return (x.run (← getThe SiteState) (← readThe SiteContext) (← readThe SiteBaseContext)).1

instance [Monad m] : MonadLift BaseHtmlM (BaseHtmlT m) where
  monadLift x := do return x.run (← readThe SiteBaseContext)

/-- Add a backref of the given `citekey` and `funName` to current document, and returns it. -/
def addBackref (citekey funName : String) : HtmlM BackrefItem := do
  let newBackref : BackrefItem := {
    citekey := citekey
    modName := (← readThe SiteBaseContext).currentName.get!
    funName := funName
    index := (← get).backrefs.size
  }
  modify fun cfg => { cfg with backrefs := cfg.backrefs.push newBackref }
  pure newBackref

/-- Add an error message to errors of current document. -/
def addError (err : String) : HtmlM Unit := do
  modify fun cfg => { cfg with errors := cfg.errors ++ err ++ "\n" }

/--
Obtains the root URL as a relative one to the current depth.
-/
def getRoot : BaseHtmlM String := do
  let rec go: Nat -> String
  | 0 => "./"
  | Nat.succ n' => "../" ++ go n'
  let d <- SiteBaseContext.depthToRoot <$> read
  return (go d)

def getHierarchy : BaseHtmlM Hierarchy := do return (← read).hierarchy
def getCurrentName : BaseHtmlM (Option Name) := do return (← read).currentName
def getResult : HtmlM AnalyzerResult := do return (← read).result
def getSourceUrl (module : Name) (range : Option DeclarationRange): HtmlM String := do return (← read).sourceLinker module range
def getDeclarationDecorator : HtmlM DeclarationDecoratorFn := do return (← read).declarationDecorator

/--
If a template is meant to be extended because it for example only provides the
header but no real content this is the way to fill the template with content.
This is untyped so HtmlM and BaseHtmlM can be mixed.
-/
def templateExtends {α β} {m} [Bind m] (base : α → m β) (new : m α) : m β :=
  new >>= base

def templateLiftExtends {α β} {m n} [Bind m] [MonadLiftT n m] (base : α → n β) (new : m α) : m β :=
  new >>= (monadLift ∘ base)
/--
Returns the doc-gen4 link to a module name.
-/
def moduleNameToLink (n : Name) : BaseHtmlM String := do
  let parts := n.components.map (Name.toString (escape := False))
  return (← getRoot) ++ (parts.intersperse "/").foldl (· ++ ·) "" ++ ".html"

/--
Returns the HTML doc-gen4 link to a module name.
-/
def moduleToHtmlLink (module : Name) : BaseHtmlM Html := do
  return <a href={← moduleNameToLink module}>{module.toString}</a>

/--
Returns the path to the HTML file that contains information about a module.
-/
def moduleNameToFile (n : Name) : FilePath :=
  if let base :: parts := n.components.map (Name.toString (escape := False)) then
    FilePath.addExtension (parts.foldl (· / ⟨·⟩) base) "html"
  else
    panic!"anonymous module name is illegal"

section Static
/-!
The following section contains all the statically included files that
are used in documentation generation, notably JS and CSS ones.
-/
  def styleCss : String := include_str "../../static/style.css"
  def faviconSvg : String := include_str "../../static/favicon.svg"
  def declarationDataCenterJs : String := include_str "../../static/declaration-data.js"
  def colorSchemeJs : String := include_str "../../static/color-scheme.js"
  def jumpSrcJs : String := include_str "../../static/jump-src.js"
  def navJs : String := include_str "../../static/nav.js"
  def expandNavJs : String := include_str "../../static/expand-nav.js"
  def howAboutJs : String := include_str "../../static/how-about.js"
  def searchJs : String := include_str "../../static/search.js"
  def instancesJs : String := include_str "../../static/instances.js"
  def importedByJs : String := include_str "../../static/importedBy.js"
  def findJs : String := include_str "../../static/find/find.js"
  def mathjaxConfigJs : String := include_str "../../static/mathjax-config.js"

end Static

/--
Returns the doc-gen4 link to a declaration name.
-/
def declNameToLink (name : Name) : HtmlM String := do
  let res ← getResult
  let module := res.moduleNames[res.name2ModIdx[name]!.toNat]!
  return (← moduleNameToLink module) ++ "#" ++ name.toString

/--
Returns the HTML doc-gen4 link to a declaration name.
-/
def declNameToHtmlLink (name : Name) : HtmlM Html := do
  return <a href={← declNameToLink name}>{name.toString}</a>

/--
Returns a name splitted into parts.
Together with "break_within" CSS class this helps browser to break a name
nicely.
-/
def breakWithin (name: String) : (Array Html) :=
  name.splitOn "."
    |> .map (fun (s: String) => <span class="name">{s}</span>)
    |> .intersperse "."
    |> List.toArray

/--
Returns the HTML doc-gen4 link to a declaration name with "break_within"
set as class.
-/
def declNameToHtmlBreakWithinLink (name : Name) : HtmlM Html := do
  return <a class="break_within" href={← declNameToLink name}>
      [breakWithin name.toString]
    </a>

/--
For a name, try to find a linkable target by stripping suffix components
that are numeric or start with `_`. Returns the first name found in name2ModIdx,
or none if nothing is found.
-/
private def findLinkableParent (name2ModIdx : Std.HashMap Name ModuleIdx) (name : Name) : Option Name :=
  match name with
  | .str parent s =>
    -- If this component starts with _ or is numeric-like, try the parent
    if s.startsWith "_" then
      findLinkableParent name2ModIdx parent
    else if name2ModIdx.contains name then
      some name
    else
      findLinkableParent name2ModIdx parent
  | .num parent _ =>
    findLinkableParent name2ModIdx parent
  | .anonymous => none

/--
Extract the module name from a private name prefix like `_private.Init.Prelude.0`.
Returns the module name (e.g., `Init.Prelude`).
-/
private def moduleFromPrivatePrefix (pfx : Name) : Name :=
  match pfx with
  | .num parent 0 => go parent
  | _ => .anonymous
where
  go (n : Name) : Name :=
    match n with
    | .str parent s =>
      if parent == Lean.privateHeader then
        .str .anonymous s
      else
        .str (go parent) s
    | _ => .anonymous

/--
Converts `RenderedCode` to HTML with declaration links.

Returns `(hasAnchor, html)` where `hasAnchor` indicates if the result contains an `<a>` tag. This is
tracked to avoid creating nested anchors (which is invalid HTML).

For `.const name` tags, it first checks whether the name is a valid link target (that is, a
non-private name in `name2ModIdx`). If so, it links directly to that name. If not, it applies
`Lean.privateToUserName?` to convert internal private names to user-facing names (e.g.,
`_private.Init.Prelude.0.Foo.helper` → `Foo.helper`) and then tries:

1. **Auxiliary name removal** (`findLinkableParent`): Strip trailing components that start with `_`
   or are numeric (e.g., `Foo.bar._proof_2` → `Foo.bar`). This handles auto-generated auxiliary
   names like match discriminant functions (`Foo.bar.match_1` → `Foo.bar`).
2. **Module link**: For private names where no declaration was found, extract the module name from
   the private prefix and link to the module page (e.g., `_private.Init.Prelude.0.Foo` → module
   `Init.Prelude`).
3. **Give up**: Wrap in `<span class="fn">` with no link.
-/
partial def renderedCodeToHtmlAux (code : RenderedCode) : HtmlM (Bool × Array Html) := do
  match code with
  | .text t => return (false, #[t])
  | .append xs =>
    xs.foldlM (init := (false, #[])) fun (a?, acc) t => do
      let (a?', acc') ← renderedCodeToHtmlAux t
      pure (a? || a?', acc ++ acc')
  | .tag tag inner =>
    let (innerHasAnchor, innerHtml) ← renderedCodeToHtmlAux inner
    match tag with
    | .const name =>
      let name2ModIdx := (← getResult).name2ModIdx
      -- Direct match: non-private name in name2ModIdx
      if name2ModIdx.contains name && (Lean.privatePrefix? name).isNone then
        let link ← declNameToLink name
        if innerHasAnchor then
          return (true, innerHtml)
        else
          return (true, #[<a href={link}>[innerHtml]</a>])
      else
        -- Resolve private names, then try the remaining steps
        let nameToSearch := Lean.privateToUserName? name |>.getD name
        -- Step 1: Auxiliary name removal
        match findLinkableParent name2ModIdx nameToSearch with
        | some target =>
          let link ← declNameToLink target
          if innerHasAnchor then
            return (true, innerHtml)
          else
            return (true, #[<a href={link}>[innerHtml]</a>])
        | none =>
          -- Step 2: Module link
          match Lean.privatePrefix? name with
          | some pfx =>
            let modName := moduleFromPrivatePrefix pfx
            if modName != Name.anonymous then
              let link ← moduleNameToLink modName
              if innerHasAnchor then
                return (true, innerHtml)
              else
                return (true, #[<a href={link}>[innerHtml]</a>])
            else
              -- Step 3: Give up
              return (innerHasAnchor, fn innerHtml)
          | none =>
            -- Step 3: Give up
            return (innerHasAnchor, fn innerHtml)
    | .sort _ =>
      let link := s!"{← getRoot}foundational_types.html"
      -- Avoid nested anchors
      -- Match original behavior: no fn wrapper when creating sort link
      if innerHasAnchor then
        return (true, innerHtml)
      else
        return (true, #[<a href={link}>[innerHtml]</a>])
    -- For Phase 1 compatibility: treat keyword/string as plain content (no extra styling)
    -- This matches the original infoFormatToHtml behavior
    | .keyword => return (innerHasAnchor, innerHtml)
    | .string => return (innerHasAnchor, innerHtml)
    | .otherExpr => return (innerHasAnchor, fn innerHtml)
where
  fn (html : Array Html) : Array Html := #[<span class="fn">[html]</span>]

/--
Convert RenderedCode to HTML with declaration links.
-/
def renderedCodeToHtml (code : RenderedCode) : HtmlM (Array Html) :=
  Prod.snd <$> renderedCodeToHtmlAux code

/-
Turns a `CodeWithInfos` object, that is basically a Lean syntax tree with
information about what the identifiers mean, into an HTML object that links
to as much information as possible.
-/
def infoFormatToHtml (i : CodeWithInfos) : HtmlM (Array Html) :=
  renderedCodeToHtml (renderTagged i)

def baseHtmlHeadDeclarations : BaseHtmlM (Array Html) := do
  return #[
    <meta charset="UTF-8"/>,
    <meta name="viewport" content="width=device-width, initial-scale=1"/>,
    <link rel="stylesheet" href={s!"{← getRoot}style.css"}/>,
    <link rel="icon" href={s!"{← getRoot}favicon.svg"}/>,
    <link rel="mask-icon" href={s!"{← getRoot}favicon.svg"} color="#000000"/>,
    <link rel="prefetch" href={s!"{← getRoot}/declarations/declaration-data.bmp"} as="image"/>
  ]

end DocGen4.Output
