/-
Copyright (c) 2021 Henrik Böving. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Henrik Böving
-/
import DocGen4.Process
import DocGen4.Output.ToHtmlFormat
import DocGen4.RenderedCode

namespace DocGen4.Output

open scoped DocGen4.Jsx
open DocGen4 (Raw escape)
open Lean System Widget Elab Process

def basePathComponent := "doc"
def basePath (buildDir : System.FilePath) := buildDir / basePathComponent
def srcBasePath (buildDir : System.FilePath) := basePath buildDir / "src"
def declarationsBasePath (buildDir : System.FilePath) := buildDir / "doc-data"

/-- The structure representing a processed bibitem. -/
structure BibItem where
  /-- The cite key as in the bib file. -/
  citekey : String
  /-- The tag generated by bib processor, e.g. `[Doe12]`.
  Should be plain text and should not be escaped. -/
  tag : String
  /-- The HTML generated by bib processor, e.g.
  `John Doe. <i>Test</i>. 2012.`-/
  html : String
  /-- The plain text form of `html` field. Should not be escaped. -/
  plaintext : String
  deriving FromJson, ToJson

/-- The structure representing a backref item. -/
structure BackrefItem where
  /-- The cite key as in the bib file. -/
  citekey : String
  /-- The name of the module. -/
  modName : Name
  /-- The name of the function, as a string. It is empty if the backref is in modstring. -/
  funName : String
  /-- The index of the backref in that module, starting from zero. -/
  index : Nat
  deriving FromJson, ToJson, Inhabited

/--
Site configuration without a rendering stream. Used by callers that only need site metadata, but
won't generate HTML, such as JSON generation.
-/
structure SiteBaseConfig where
  /--
  The build directory (provided by lake).
  -/
  buildDir : System.FilePath
  /--
  The module hierarchy as a tree structure.
  -/
  hierarchy : Hierarchy
  /--
  How far away we are from the page root, used for relative links to the root.
  -/
  depthToRoot: Nat
  /--
  The name of the current module if there is one, there exist a few
  pages that don't have a module name.
  -/
  currentName : Option Name
  /--
  The list of references, as an array.
  -/
  refs : Array BibItem

/--
The context used in the `BaseHtmlM` monad for HTML templating.
Extends `SiteBaseConfig` with a stream for writing HTML output.
-/
structure SiteBaseContext extends SiteBaseConfig where
  /--
  The stream to write HTML output to.
  -/
  stream : IO.FS.Stream

def setCurrentName (name : Name) (ctx : SiteBaseContext) := { ctx with currentName := some name }
def SiteBaseConfig.setCurrentName (name : Name) (cfg : SiteBaseConfig) := { cfg with currentName := some name }

abbrev BaseHtmlT := ReaderT SiteBaseContext
abbrev BaseHtmlM := BaseHtmlT IO

/-! ## Write helpers

These are the concrete implementations referenced by JSX macro expansion.
They read the stream from `SiteBaseContext` via the reader monad. -/

section
variable [Monad m] [MonadReaderOf SiteBaseContext m] [MonadLiftT IO m]

@[always_inline, inline] def putHtml (s : String) : m Unit := do
  (← read).stream.putStr s

@[always_inline, inline] def putEscaped (s : String) : m Unit := putHtml (escape s)



namespace Html

/-- Writes escaped text content to the HTML stream. -/
@[always_inline, inline] def text (s : String) : m Unit := putEscaped s

/-- Writes raw (unescaped) HTML content to the stream. -/
@[always_inline, inline] def rawText (s : String) : m Unit := putHtml s

end Html

def putOpenTag (tag : String) (attrs : Array (String × String)) : m Unit := do
  putHtml s!"<{tag}"
  for (k, v) in attrs do putHtml s!" {k}=\"{escape v}\""
  putHtml ">"

@[always_inline, inline] def putCloseTag (tag : String) : m Unit := putHtml s!"</{tag}>"

namespace Html

/-- Writes an HTML element with open/close tags wrapping a body action. -/
def element (tag : String) (attrs : Array (String × String)) (body : m Unit) : m Unit := do
  putOpenTag tag attrs
  body
  putCloseTag tag

end Html

scoped instance : Coe String (m Unit) where
  coe s := putEscaped s

scoped instance : Coe Raw (m Unit) where
  coe r := putHtml r.html

end

/--
The writable state used in the `HtmlM` monad for HTML templating.
-/
structure SiteState where
  /--
  The list of back references, as an array.
  -/
  backrefs : Array BackrefItem := #[]
  /--
  The errors occurred during the process.
  -/
  errors : String := ""

/--
Declaration decorator function type: given a module name, declaration name, and declaration kind,
writes optional extra HTML to inject into the declaration's rendering. This enables external tools
to add badges, links, or other decorations to declarations.
-/
abbrev DeclarationDecoratorFn := Name → Name → String → BaseHtmlM Unit

/--
The default declaration decorator that produces no extra HTML.
-/
def defaultDeclarationDecorator : DeclarationDecoratorFn := fun _ _ _ => pure ()

/--
The read-only context used in the `HtmlM` monad for HTML templating.
-/
structure SiteContext where
  /--
  The full analysis result from the Process module.
  -/
  result : AnalyzerResult
  /--
  A function to link declaration names to their source URLs, usually Github ones.
  -/
  sourceLinker : Name → Option DeclarationRange → String
  /--
  The references as a map.
  -/
  refsMap : Std.HashMap String BibItem
  /--
  A function to decorate declarations with extra HTML (e.g., verification badges).
  Receives (moduleName, declarationName, declarationKind) and writes extra HTML.
  Defaults to producing no extra HTML.
  -/
  declarationDecorator : DeclarationDecoratorFn := defaultDeclarationDecorator

abbrev HtmlT (m) := StateT SiteState <| ReaderT SiteContext <| BaseHtmlT m
abbrev HtmlM := HtmlT IO

def HtmlT.run (x : HtmlT m α) (state : SiteState) (ctx : SiteContext)
    (baseCtx : SiteBaseContext) : m (α × SiteState) :=
  StateT.run x state |>.run ctx |>.run baseCtx

def HtmlM.run (x : HtmlM α) (state : SiteState) (ctx : SiteContext)
    (baseCtx : SiteBaseContext) : IO (α × SiteState) :=
  HtmlT.run x state ctx baseCtx


/-- Add a backref of the given `citekey` and `funName` to current document, and returns it. -/
def addBackref (citekey funName : String) : HtmlM BackrefItem := do
  let newBackref : BackrefItem := {
    citekey := citekey
    modName := (← readThe SiteBaseContext).currentName.get!
    funName := funName
    index := (← get).backrefs.size
  }
  modify fun cfg => { cfg with backrefs := cfg.backrefs.push newBackref }
  pure newBackref

/-- Add an error message to errors of current document. -/
def addError (err : String) : HtmlM Unit := do
  modify fun cfg => { cfg with errors := cfg.errors ++ err ++ "\n" }

/--
Obtains the root URL relative to the given depth.
-/
def getRoot : BaseHtmlM String := do
  let rec go : Nat → String
    | 0 => "./"
    | n + 1 => "../" ++ go n
  return go (← read).depthToRoot

def getHierarchy : BaseHtmlM Hierarchy := do return (← read).hierarchy
def getCurrentName : BaseHtmlM (Option Name) := do return (← read).currentName
def getResult : HtmlM AnalyzerResult := do return (← read).result
def getSourceUrl (module : Name) (range : Option DeclarationRange): HtmlM String := do return (← read).sourceLinker module range
def getDeclarationDecorator : HtmlM DeclarationDecoratorFn := do return (← read).declarationDecorator

/--
Returns the doc-gen4 link to a module name.
-/
def moduleNameToLink (n : Name) : BaseHtmlM String := do
  let root ← getRoot
  let parts := n.components.map (Name.toString (escape := False))
  return root ++ (parts.intersperse "/").foldl (· ++ ·) "" ++ ".html"

/--
Returns the HTML doc-gen4 link to a module name.
-/
def moduleToHtmlLink (module : Name) : BaseHtmlM Unit := do
  <a href={← moduleNameToLink module}>{module.toString}</a>

/--
Returns the path to the HTML file that contains information about a module.
-/
def moduleNameToFile (n : Name) : FilePath :=
  if let base :: parts := n.components.map (Name.toString (escape := False)) then
    FilePath.addExtension (parts.foldl (· / ⟨·⟩) base) "html"
  else
    panic!"anonymous module name is illegal"

section Static
/-!
The following section contains all the statically included files that
are used in documentation generation, notably JS and CSS ones.
-/
  def styleCss : String := include_str "../../static/style.css"
  def faviconSvg : String := include_str "../../static/favicon.svg"
  def declarationDataCenterJs : String := include_str "../../static/declaration-data.js"
  def colorSchemeJs : String := include_str "../../static/color-scheme.js"
  def jumpSrcJs : String := include_str "../../static/jump-src.js"
  def navJs : String := include_str "../../static/nav.js"
  def expandNavJs : String := include_str "../../static/expand-nav.js"
  def howAboutJs : String := include_str "../../static/how-about.js"
  def searchJs : String := include_str "../../static/search.js"
  def instancesJs : String := include_str "../../static/instances.js"
  def importedByJs : String := include_str "../../static/importedBy.js"
  def findJs : String := include_str "../../static/find/find.js"
  def mathjaxConfigJs : String := include_str "../../static/mathjax-config.js"

end Static

/--
Returns the doc-gen4 link to a declaration name.
-/
def declNameToLink (name : Name) : HtmlM String := do
  let res ← getResult
  let module := res.moduleNames[res.name2ModIdx[name]!.toNat]!
  return (← moduleNameToLink module) ++ "#" ++ name.toString

/--
Returns the HTML doc-gen4 link to a declaration name.
-/
def declNameToHtmlLink (name : Name) : HtmlM Unit := do
  <a href={← declNameToLink name}>{name.toString}</a>

/--
Writes a name split into parts, each wrapped in a span.
Together with "break_within" CSS class this helps browser to break a name nicely.
-/
def breakWithin [Monad m] [MonadReaderOf SiteBaseContext m] [MonadLiftT IO m] (name: String) : m Unit := do
  let parts := name.splitOn "."
  for part in parts, i in [:parts.length] do
    if i > 0 then
      Html.text "."
    (<span class="name">{part}</span>)

/--
Returns the HTML doc-gen4 link to a declaration name with "break_within"
set as class.
-/
def declNameToHtmlBreakWithinLink (name : Name) : HtmlM Unit := do
  <a class="break_within" href={← declNameToLink name}>
    {breakWithin name.toString}
  </a>

/--
For a name, try to find a linkable target by stripping suffix components
that are numeric or start with `_`. Returns the first name found in name2ModIdx,
or none if nothing is found.
-/
private def findLinkableParent (name2ModIdx : Std.HashMap Name ModuleIdx) (name : Name) : Option Name :=
  match name with
  | .str parent s =>
    -- If this component starts with _ or is numeric-like, try the parent
    if s.startsWith "_" then
      findLinkableParent name2ModIdx parent
    else if name2ModIdx.contains name then
      some name
    else
      findLinkableParent name2ModIdx parent
  | .num parent _ =>
    findLinkableParent name2ModIdx parent
  | .anonymous => none

/--
Extract the module name from a private name prefix like `_private.Init.Prelude.0`.
Returns the module name (e.g., `Init.Prelude`).
-/
private def moduleFromPrivatePrefix (pfx : Name) : Name :=
  match pfx with
  | .num parent 0 => go parent
  | _ => .anonymous
where
  go (n : Name) : Name :=
    match n with
    | .str parent s =>
      if parent == Lean.privateHeader then
        .str .anonymous s
      else
        .str (go parent) s
    | _ => .anonymous

/-- Captures the HTML output of an HtmlM action and also returns its result. -/
def captureHtmlWith (action : HtmlM α) : HtmlM (String × α) := do
  let ref ← IO.mkRef {}
  let bufStream := IO.FS.Stream.ofBuffer ref
  let result ← withTheReader SiteBaseContext (fun ctx => { ctx with stream := bufStream }) action
  return (String.fromUTF8! (← ref.get).data, result)

/-- Captures the HTML output of an HtmlM action as a string. -/
def captureHtml (action : HtmlM Unit) : HtmlM String := do
  return (← captureHtmlWith action).1

/-- Captures the HTML output of a BaseHtmlM action as a string. -/
def captureBaseHtml (action : BaseHtmlM Unit) : BaseHtmlM String := do
  let ref ← IO.mkRef {}
  let bufStream := IO.FS.Stream.ofBuffer ref
  withTheReader SiteBaseContext (fun ctx => { ctx with stream := bufStream }) action
  return String.fromUTF8! (← ref.get).data

/-- Runs an HtmlM action inside a BaseHtmlM context using an IO.Ref for state. -/
def runHtmlInBase (action : HtmlM Unit) (siteCtx : SiteContext) (stateRef : IO.Ref SiteState) : BaseHtmlM Unit := do
  let baseCtx ← read
  let s ← stateRef.get
  let ((), s') ← HtmlM.run action s siteCtx baseCtx
  stateRef.set s'

/-- Runs a BaseHtmlM action, writing output directly to a file. -/
def runHtmlToFile (action : BaseHtmlM Unit) (config : SiteBaseConfig) (path : FilePath) : IO Unit := do
  let handle ← IO.FS.Handle.mk path .write
  let fileStream := IO.FS.Stream.ofHandle handle
  action.run { toSiteBaseConfig := config, stream := fileStream }

/-- Runs an HtmlM action for its return value, auto-providing a buffer stream. -/
def HtmlM.eval (x : HtmlM α) (state : SiteState) (ctx : SiteContext)
    (config : SiteBaseConfig) : IO (α × SiteState) := do
  let ref ← IO.mkRef {}
  let bufStream := IO.FS.Stream.ofBuffer ref
  HtmlM.run x state ctx { toSiteBaseConfig := config, stream := bufStream }

/--
Converts RenderedCode to HTML with declaration links. Returns `true` if the result contains an
anchor tag and thus shouldn't be wrapped by a surrounding one.
-/
partial def renderedCodeToHtmlAux (code : RenderedCode) : HtmlM Bool := do
  match code with
  | .text t =>
    Html.text t
    return false
  | .append xs =>
    let mut hasAnchor := false
    for t in xs do
      let a? ← renderedCodeToHtmlAux t
      hasAnchor := hasAnchor || a?
    return hasAnchor
  | .tag tag inner =>
    match tag with
    | .const name =>
      let name2ModIdx := (← getResult).name2ModIdx
      -- Always capture inner to a string since we may need to wrap it
      let (innerStr, innerHasAnchor) ← captureHtmlWith (renderedCodeToHtmlAux inner)
      if name2ModIdx.contains name then
        if innerHasAnchor then
          Html.rawText innerStr
          return true
        else
          let link ← declNameToLink name
          (<a href={link}>{Html.rawText innerStr}</a>)
          return true
      else
        let nameToSearch := Lean.privateToUserName? name |>.getD name
        match findLinkableParent name2ModIdx nameToSearch with
        | some target =>
          if innerHasAnchor then
            Html.rawText innerStr
            return true
          else
            let link ← declNameToLink target
            (<a href={link}>{Html.rawText innerStr}</a>)
            return true
        | none =>
          match Lean.privatePrefix? name with
          | some pfx =>
            let modName := moduleFromPrivatePrefix pfx
            if modName != .anonymous then
              if innerHasAnchor then
                Html.rawText innerStr
                return true
              else
                let link ← moduleNameToLink modName
                (<a href={link}>{Html.rawText innerStr}</a>)
                return true
            else
              (<span class="fn">{Html.rawText innerStr}</span>)
              return innerHasAnchor
          | none =>
            (<span class="fn">{Html.rawText innerStr}</span>)
            return innerHasAnchor
    | .sort _ =>
      let (innerStr, innerHasAnchor) ← captureHtmlWith (renderedCodeToHtmlAux inner)
      if innerHasAnchor then
        Html.rawText innerStr
        return true
      else
        let link := s!"{← getRoot}foundational_types.html"
        (<a href={link}>{Html.rawText innerStr}</a>)
        return true
    | .keyword =>
      renderedCodeToHtmlAux inner
    | .string =>
      renderedCodeToHtmlAux inner
    | .otherExpr =>
      let (innerStr, innerHasAnchor) ← captureHtmlWith (renderedCodeToHtmlAux inner)
      (<span class="fn">{Html.rawText innerStr}</span>)
      return innerHasAnchor

/--
Converts RenderedCode to HTML with declaration links.
-/
def renderedCodeToHtml (code : RenderedCode) : HtmlM Unit := do
  let _ ← renderedCodeToHtmlAux code

/-
Turns a `CodeWithInfos` object, that is basically a Lean syntax tree with
information about what the identifiers mean, into an HTML object that links
to as much information as possible.
-/
def infoFormatToHtml (i : CodeWithInfos) : HtmlM Unit :=
  renderedCodeToHtml (renderTagged i)

def baseHtmlHeadDeclarations : BaseHtmlM Unit := do
  (<meta charset="UTF-8"/>)
  (<meta name="viewport" content="width=device-width, initial-scale=1"/>)
  (<link rel="stylesheet" href={s!"{← getRoot}style.css"}/>)
  (<link rel="icon" href={s!"{← getRoot}favicon.svg"}/>)
  (<link rel="mask-icon" href={s!"{← getRoot}favicon.svg"} color="#000000"/>)
  (<link rel="prefetch" href={s!"{← getRoot}/declarations/declaration-data.bmp"} as="image"/>)

end DocGen4.Output
