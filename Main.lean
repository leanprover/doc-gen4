import DocGen4
import Lean
import Cli

open DocGen4 Lean Cli

def defaultMaxHeartbeats : Nat := 100_000_000

/-- Parse a natural number, allowing underscores as separators (e.g., "100_000_000").

 See discussion: https://leanprover.zulipchat.com/#narrow/channel/270676-lean4/topic/String.2EtoNat.3F.20and.20String.2EtoInt.3F.20handling.20underscores/with/562357458
 See this related issue: https://github.com/leanprover/lean4/issues/11538
 -/
def parseNatWithUnderscores (s : String) : Option Nat :=
  (s.replace "_" "").toNat?

/-- Get maxHeartbeats from CLI flag, falling back to environment variable, then default. -/
def getMaxHeartbeats (p : Parsed) : IO Nat := do
  match p.flag? "max-heartbeats" with
  | some flag => pure <| (parseNatWithUnderscores (flag.as! String)).getD defaultMaxHeartbeats
  | none => do
    match ← IO.getEnv "DOCGEN_MAX_HEARTBEATS" with
    | some s => pure <| (parseNatWithUnderscores s).getD defaultMaxHeartbeats
    | none => pure defaultMaxHeartbeats

def getTopLevelModules (p : Parsed) : IO (List String) :=  do
  let topLevelModules := p.variableArgsAs! String |>.toList
  if topLevelModules.length == 0 then
    throw <| IO.userError "No topLevelModules provided."
  return topLevelModules

def runHeaderDataCmd (p : Parsed) : IO UInt32 := do
  let buildDir := match p.flag? "build" with
    | some dir => dir.as! String
    | none => ".lake/build"
  headerDataOutput buildDir
  return 0

def runSingleCmd (p : Parsed) : IO UInt32 := do
  let buildDir := match p.flag? "build" with
    | some dir => dir.as! String
    | none => ".lake/build"
  let maxHeartbeats ← getMaxHeartbeats p
  let relevantModules := #[p.positionalArg! "module" |>.as! String |> String.toName]
  let sourceUri := p.positionalArg! "sourceUri" |>.as! String
  let (doc, hierarchy) ← load (.analyzeConcreteModules relevantModules) maxHeartbeats
  let baseConfig ← getSimpleBaseContext buildDir hierarchy
  discard <| htmlOutputResults baseConfig doc (some sourceUri)
  return 0

def runIndexCmd (p : Parsed) : IO UInt32 := do
  let buildDir := match p.flag? "build" with
    | some dir => dir.as! String
    | none => ".lake/build"
  let hierarchy ← Hierarchy.fromDirectory (Output.basePath buildDir)
  let baseConfig ← getSimpleBaseContext buildDir hierarchy
  htmlOutputIndex baseConfig
  return 0

def runGenCoreCmd (p : Parsed) : IO UInt32 := do
  let buildDir := match p.flag? "build" with
    | some dir => dir.as! String
    | none => ".lake/build"
  let maxHeartbeats ← getMaxHeartbeats p
  let manifestOutput? := (p.flag? "manifest").map (·.as! String)
  let module := p.positionalArg! "module" |>.as! String |> String.toName
  let (doc, hierarchy) ← load (.analyzePrefixModules module) maxHeartbeats
  let baseConfig ← getSimpleBaseContext buildDir hierarchy
  let outputs ← htmlOutputResults baseConfig doc none
  if let .some manifestOutput := manifestOutput? then
    IO.FS.writeFile manifestOutput (Lean.toJson outputs).compress
  return 0

def runDocGenCmd (_p : Parsed) : IO UInt32 := do
  IO.println "You most likely want to use me via Lake now, check my README on Github on how to:"
  IO.println "https://github.com/leanprover/doc-gen4"
  return 0

def runBibPrepassCmd (p : Parsed) : IO UInt32 := do
  let buildDir := match p.flag? "build" with
    | some dir => dir.as! String
    | none => ".lake/build"
  if p.hasFlag "none" then
    IO.println "INFO: reference page disabled"
    disableBibFile buildDir
  else
    match p.variableArgsAs! String with
    | #[source] =>
      let contents ← IO.FS.readFile source
      if p.hasFlag "json" then
        IO.println "INFO: 'references.json' will be copied to the output path; there will be no 'references.bib'"
        preprocessBibJson buildDir contents
      else
        preprocessBibFile buildDir contents Bibtex.process
    | _ => throw <| IO.userError "there should be exactly one source file"
  return 0

/--
 See discussion: https://leanprover.zulipchat.com/#narrow/channel/270676-lean4/topic/String.2EtoNat.3F.20and.20String.2EtoInt.3F.20handling.20underscores/with/562357458
 If https://github.com/leanprover/lean4/issues/11538 is resolved, change "max-heartbeats" to be of type Nat directly.
 See: https://github.com/leanprover/lean4/pull/11541
 -/
def singleCmd := `[Cli|
  single VIA runSingleCmd;
  "Only generate the documentation for the module it was given, might contain broken links unless all documentation is generated."

  FLAGS:
    b, build : String; "Build directory."
    "max-heartbeats" : String; "Maximum heartbeats for elaboration (default: 100_000_000). Supports underscores as separators. Can also be set via DOCGEN_MAX_HEARTBEATS env var."

  ARGS:
    module : String; "The module to generate the HTML for. Does not have to be part of topLevelModules."
    sourceUri : String; "The sourceUri as computed by the Lake facet"
]

def indexCmd := `[Cli|
  index VIA runIndexCmd;
  "Index the documentation that has been generated by single."

  FLAGS:
    b, build : String; "Build directory."
]

def genCoreCmd := `[Cli|
  genCore VIA runGenCoreCmd;
  "Generate documentation for the specified Lean core module as they are not lake projects."

  FLAGS:
    b, build : String; "Build directory."
    m, manifest : String; "Manifest output, to list all the files generated."
    "max-heartbeats" : String; "Maximum heartbeats for elaboration (default: 100_000_000). Supports underscores as separators. Can also be set via DOCGEN_MAX_HEARTBEATS env var."

  ARGS:
    module : String; "The module to generate the HTML for."
]

def bibPrepassCmd := `[Cli|
  bibPrepass VIA runBibPrepassCmd;
  "Run the bibliography prepass: copy the bibliography file to output directory. By default it assumes the input is '.bib'."

  FLAGS:
    n, none; "Disable bibliography in this project."
    j, json; "The input file is '.json' which contains an array of objects with 4 fields: 'citekey', 'tag', 'html' and 'plaintext'."
    b, build : String; "Build directory."

  ARGS:
    ...source : String; "The bibliography file. We only support one file for input. Should be '.bib' or '.json' according to flags."
]

def headerDataCmd := `[Cli|
  headerData VIA runHeaderDataCmd;
  "Produce `header-data.bmp`, this allows embedding of doc-gen declarations into other pages and more."

  FLAGS:
    b, build : String; "Build directory."
]

def docGenCmd : Cmd := `[Cli|
  "doc-gen4" VIA runDocGenCmd; ["0.1.0"]
  "A documentation generator for Lean 4."

  SUBCOMMANDS:
    singleCmd;
    indexCmd;
    genCoreCmd;
    bibPrepassCmd;
    headerDataCmd
]

def main (args : List String) : IO UInt32 :=
  docGenCmd.validate args
